# 00_context: 共通コンテキスト

あなたは Python / FastAPI / HTML / JavaScript を使って、
PoCレベルの Web アプリケーションを実装するフルスタックエンジニア兼アーキテクトです。

このプロジェクトは、

> 「没案を含む過去の意思決定データを活用し、  
>  新しい企画を“問い”によってブラッシュアップする自己レビュー用ツール」

の **技術 PoC（Proof of Concept）** を作ることを目的とします。

ここで扱うのは単なる「アイデア」ではなく、  
**複数の選択肢と評価、そして GO / NoGo / 継続判断までを含んだ「意思決定ケース（DecisionCase）」** です。


---

## 1. 背景：新規事業開発における「学習しない組織」

多くの事業会社やDX案件の現場では、次のような構造的な問題があると仮定します。

- 毎年よく似た新規事業案やDX案が出てきて、**ほぼ同じ論点で何度も却下される**
- 過去の案件資料はファイルサーバ・個人PC・散在したフォルダに埋もれ、  
  「なぜその案が通ったのか / 通らなかったのか」が共有されない
- 部署異動や担当者交代があると、過去の失敗議論の履歴にアクセスできず、  
  新任メンバーが毎回ゼロから同じ壁にぶつかる
- 振り返り（ポストモーテム）を実施しても、**レポートが次の案件と構造的につながらない**

結果として、

> 新規事業に投じた時間・コストの割に、  
> 組織としての「意思決定の質」があまり向上していない

という「学習しない組織」状態が生まれている、という問題意識です。

このプロダクトは、この「学習されない意思決定」と「生かされない没案」のギャップを埋め、  
**新規事業開発のプロセスそのものを組織の資産に変えていく** ことを目的とします。

---

## 2. プロダクトのコアコンセプト

### 2.1 企画立案OSとしての位置づけ

プロダクトの核心は、

> 「組織が同じ失敗・同じ議論を何度も繰り返さなくて済むようにする“企画立案OS”」  
> 「過去の判断と経験から、今の企画をどう磨いていくべきかを教えてくれるAI」

です。

AIの役割は **「代わりに決める」ことではなく**、

- どこがまだ粗いのか
- どこを詰めれば案が一段マシになるのか

を **「問い」という形で返すこと** にあります。

### 2.2 「アイデア」と「意思決定ケース」の違い

このプロダクトは、「アイデア」ではなく「意思決定ケース」を扱います。

- **アイデア**
  - 一つの案だけが独立して存在
  - 例：「中山間地域で高齢者向けの乗合タクシー事業をやる」
  - 付随情報：概要、ターゲット、狙い、KPI案
  - これだけでは「なぜ通った/通らなかったか」「他にどんな選択肢があったか」が分からない

- **意思決定ケース（DecisionCase）**
  - ある目的・状況の下で、複数の選択肢を比較し、  
    どれかを選んだ / 全部見送ったという「判断の1セット」
  - 構造イメージ：
    - コンテキスト（地域・期間・背景）
    - 目的・課題
    - 複数の Option（案A, 案B, 案C…）
    - 各 Option への評価（Pros/Cons、リスク、制約）
    - 採用された Option（or 全部ボツ）
    - 実施結果（あれば）
  - これらが揃うと、
    - その組織が何を重視して意思決定しているか
    - どんなタイプの案が「惜しい没」になりやすいか
    - どの論点が毎回ボトルネックになるか
    が見えてくる

PoC段階では、実装のシンプルさを優先し、  
**「代表的な1回の意思決定」を1つの DecisionCase として扱う** ことにします。

---

## 3. 今回の技術PoCの目的・非ゴール

### 3.1 PoCの核心問い

このPoCで検証したいコアは次の1行です。

> **AIが没案から生成した「問い」は、本当に人間の判断を変えうるのか？**

具体的には：

- 新規事業案件のドラフト（企画メモ）を入力したとき、
- 過去の意思決定ケースから類似案件を検索し、
- そこから生成された 3〜7 個の問いが、
- 企画担当者の自己レビューにおいて「実際に役立つ」と感じられるか

を検証します。

### 3.2 ゴール

- ユーザーが新しい企画メモを入力すると：
  1. 類似する意思決定ケース（採用・不採用を含む）が表示される
  2. 類似ケースの評価理由をもとに生成された **3〜7 個の問い** が提示される
  3. ユーザーが問いを見て・考えて・必要ならメモを修正する
  4. 各問いの有用性と行動（修正したかどうか）をログとして記録できる

### 3.3 非ゴール（今回やらないこと）

- 予算・売上・KPIなどの数値を **予測するモデル（回帰・分類）** は作らない
- 「類似案件検索の精度最適化」そのものは、今回の中心テーマではない（シンプルなTF-IDFでよい）
- 本番運用レベルのセキュリティ・権限管理・テナント分離などは扱わない
- 高度なフロントエンド（React/Vue等）ではなく、HTML+素のJSでよい

---

## 4. ターゲットとユースケース

### 4.1 ターゲット分野（技術PoCの想定ドメイン）

第一ターゲットは **事業会社の新規事業開発** であり、特に：

- 分野A：B2B SaaS / ITサービス企業
  - 特徴：常に新機能・新プロダクトが出る、企画書・ロードマップ文化がある
- 分野B：伝統的大企業のDX / 新規事業室
  - 特徴：企画は多いが、社内調整や既存事業との衝突でよく没になる

ただし、コード自体はドメインに依存しない汎用的な構造とします。

### 4.2 コアユースケース（PoCで扱うメイン）

**コアユースケース①：企画書ドラフト段階の「自己レビュー」**

- 想定ユーザー：
  - 新規事業担当、PdM、DX室メンバー
- 使い方：
  1. ユーザーがラフな企画メモを入力（目的・ターゲット・提供価値・収益モデルなど）
  2. システムが過去の意思決定ケースから類似案件を検索
  3. 類似案件の「よく出た懸念・つぶれた理由」を整理し、問いとして提示
- 得られる価値：
  - 経営会議にかける前に、「毎回突っ込まれている穴」を事前に埋められる
  - 新人や異動組でも、「その会社らしいチェック観」を短期間で身につけられる
  - 没案が、思考のフレームワークとして蘇る

※ゲートレビュー用、ポストモーテム用も将来ユースケースとして想定するが、  
今回のUIと体験設計は「自己レビュー」にフォーカスする。

---

## 5. データ設計（DecisionCase）

### 5.1 「意思決定ケース」としてカウントする条件

1. 組織として一度は **正式にレビューされている** こと
   - 企画会議・新規事業委員会・部門内会議などで議題になっている
2. GO / NoGo / 継続検討 のいずれかが明確に決まっていること
3. なぜその判断になったかが **1〜3文で説明できる** こと

同じテーマに複数の意思決定がある場合もありますが、PoCでは：

- 「学びが最も大きい一回の意思決定」を代表ケースとして記録
- それ以前の細かい判断は `summary` の中に背景として要約する

### 5.2 「アイデア」と「意思決定ケース」の線引き

- **アイデアにとどまるもの（扱わない）**
  - 個人のメモレベルの案
  - 会議に出していない下書き・ブレスト
  - なんとなく立ち消えた提案（結論も理由も曖昧）

- **意思決定ケースとして扱うもの（扱う）**
  - 何らかの会議体で正式に議論された
  - その時点での結論が決まっている
  - 「なぜそう決めたか」を数行で説明できる

---

## 6. 最小スキーマ（PoCで扱うカラム）

DecisionCase は、次の用途を満たすように設計します：

- 類似検索（Embedding/TF-IDFに食わせるテキスト）
- 問い生成（LLMに渡す文脈）
- 絞り込み・分析（タグ・ステータスでフィルタ）

### 6.1 第一層：PoCで必須のカラム

- `id: string | int`  
  - 一意識別子（技術的に必須）
- `project_id: string | int | null`
  - 将来 Project テーブルと紐づけるための緩い外部キー
- `title: string`
  - 一覧表示・類似ケースリストに出すラベル
- `summary: string (text)`
  - Embedding/TF-IDF のメイン入力
  - 含める内容：
    - 目的（何のための事業か）
    - ターゲット（誰向けか）
    - 提供価値（何をよくするのか）
    - ざっくりした施策・ビジネスモデル
    - 必要なら検討プロセスの要約（2〜3行）
  - 文字数ガイド：300〜800字程度で揃える
- `status: string`
  - `"adopted" | "rejected" | "pending"`
  - 没案かどうかの判定に使う
- `main_reason: string (text)`
  - **問い生成の核となる情報**
  - 「なぜその判断になったか」を1〜3文で書く
- `tags: list[string]`
  - 荒いフィルタ・文脈のヒント
  - 例：["B2B", "SaaS", "製造業", "設備保全", "地方企業", "市場規模"]

### 6.2 第二層：あった方がいいメタデータ（nullable OK）

- `decision_date: string (YYYY-MM-DD) | null`
  - 将来「最近のケースだけ見る」等に使える
- `decision_level: string | null`
  - 例："事業部長会議", "経営会議", "新規事業委員会"
- `source: string | null`
  - 例："dummy", "interview", "internal_doc"

### 6.3 第三層：PoCでは切り捨てるもの

- 売上予測・NPVなどの詳細数値
- 会議参加者の一覧・発言ログ
- 業界コード・部署コードなどの完全正規化された情報

---

## 7. コア機能と三層の「問い」

### 7.1 機能1：類似ケース＋類似オプションの計算（PoC版）

- 入力：
  - 新しく立てた企画の概要・目的・ターゲット・規模感など（`NewIdea`)
- 出力：
  - 過去の DecisionCase から、コンテキスト・ゴール・Option が似ているケース（採用・没案両方）

PoCではオプションレベルの構造化までは行わず、  
`summary`＋`tags`＋`main_reason` ベースの類似検索を TF-IDF で実装します。

### 7.2 機能2：「よく出てきた論点・懸念」の抽出（簡易版）

構想としては：

- 過去 DecisionCase / Evaluation に評価軸・懸念をラベル付けし、
- 「実行体制が曖昧」「ターゲットが甘い」「既存事業とカニバる」といった NG パターンを抽象化し、
- 懸念タイプごとの問いテンプレートを作る

PoCの実装では、まずは `main_reason` テキストと `tags` を使い、

- どんなタイプの懸念か（市場規模 / 実行体制 / カニバリ / 規制リスク 等）を簡易に推定し、
- それに紐づく問いテンプレートを呼び出す

というルールベース＋LLMベースのハイブリッドを狙います（段階的実装でOK）。

### 7.3 機能3：チェックリスト・問いの生成（3レイヤー）

このプロダクトの差別化ポイントは **「問い」を3レイヤーで設計すること** です。

- **レイヤー1：ドメイン非依存の「企画の基礎チェック」**
  - 目的・KPI
    - 「一次目的と二次目的は明確か？」
    - 「成否を判断する具体的な指標は定義されているか？」
  - 対象・スコープ
    - 「対象者は誰で、スコープ外はどこまでか？」
  - 実行体制
    - 「日常運用はどの部署・ロールが担うか？」
  - コスト・撤退条件
    - 「どこまで赤字を許容するのか？」
    - 「どの条件なら撤退 / 縮小するのか？」

- **レイヤー2：組織ごとの「よく出る論点」から作る問い**
  - 失敗パターンの例：
    - 実行体制が曖昧
    - 既存事業との重複
    - ターゲットがニッチすぎる
  - 懸念 → 問い の例：
    - 懸念「実行体制があいまい」
      → 問い「この事業の日常運用責任者は誰ですか？」
    - 懸念「既存事業との重複」
      → 問い「既存施策と異なる部分は何ですか？」

- **レイヤー3：今回の案の特徴から動的に生成する問い**
  - 例：
    - 予算が平均よりかなり大きい
      → 「この規模の投資を正当化する定量的根拠は何ですか？」
    - 規制やコンプラに強く依存している
      → 「どのガイドライン / 規制文書を前提として設計していますか？」

### 7.4 問いの形・UX

PoCでは、問いのUXを以下のように定義します。

- 1セッションで出す問いは **3〜7個** に絞る
- 各問いについて：
  - 記述式で答えを書ける
  - または「検討済み / 未検討」のチェックを付けられる
- 体験として：
  - ライトユーザーは「問いを眺めるだけ」でもよい
  - 本気ユーザーは、その場でメモを書き、**それがそのまま企画書の素材になる**

「未検討が多い ＝ この案はまだ粗い」という自己評価軸も同時に提供する設計を目指します。

---

## 8. 評価指標（仮説A/Bに対応）

### 8.1 仮説A：問いの有用性

- **2-1. 質問単位の主観評価（メイン指標）**
  - 質問：「この問いは、あなたの企画のブラッシュアップに役立ちましたか？」
  - 回答形式：5段階（全く役に立たない〜とても役に立つ）
  - 成功条件例：
    - 全体平均スコア：4.0以上
    - 「4以上」の回答が全体の60%以上

- **2-2. 行動ベースの指標（サブ）**
  - 質問：「この問いによって、企画メモの内容を具体的に修正・追記しましたか？」
  - 回答形式：Yes/No ＋ 任意コメント
  - 成功条件例：
    - Yes の割合：30〜40%以上

### 8.2 仮説B：体験としての価値

- **3-1. 体験の有効性**
  - 質問：「このツールを使った自己レビューは、何も使わない場合と比べて考えを整理するのに役立ちましたか？」
  - 回答形式：5段階
  - 成功条件例：
    - 平均スコア：4.0以上

- **3-2. 再利用意向**
  - 質問：「次に新しい案を考えるときもこのツールを使いたいですか？」
  - 回答形式：0〜10 の11段階
  - 成功条件例：
    - 平均：7.0以上
    - 9〜10の割合：30%以上

- **3-3. 自己評価ベースの「質の向上感」**
  - 質問：「このツールを使った結果、企画案の“説得力”などの質はどの程度高まったと感じますか？」
  - 回答形式：5段階
  - 成功条件例：
    - 4以上が50%以上

---

## 9. ログ設計（実装レベル）

1セッション単位で次を JSON に保存します。

- `session_id: str`（UUID）
- `created_at: str`（ISO8601）
- `new_idea: NewIdea`
- `similar_cases: list[DecisionCase]`（少なくとも id, title）
- `questions: list[Question]`
- `feedbacks: list[QuestionFeedback]`
- 追加で取れる操作ログ（任意）：
  - 各問いについて：
    - `clicked_detail`（類似ケース詳細を開いたか）
    - `note_written`（メモ欄に何か書かれたか）
    - `checked_done`（「検討済み」が押されたか）
  - `session_start_time` / `session_end_time`（自己レビュー時間）

保存先は `backend/app/logs/session_{session_id}.json` とし、同期I/Oで十分です。

---

## 10. 技術スタックとディレクトリ構成

### 10.1 技術

- Python 3.x
- FastAPI
- Pydantic
- scikit-learn（TF-IDF＋cosine similarity）
- （将来）OpenAI API / Embeddings（今回のPoCはTF-IDF中心）
- HTML + 素の JavaScript（fetch API）

### 10.2 想定ディレクトリ構成

```text
backend/
  app/
    main.py             # FastAPI エントリポイント
    models.py           # Pydantic モデル定義
    config.py           # 設定（将来のLLM APIキーなど）
    services/
      loader.py         # decision_case.json の読み込み・キャッシュ
      similarity.py     # 類似度計算（TF-IDF）
      question_generator.py  # 三層の問い生成ロジック
      logging_service.py     # セッションログ・評価の保存
    data/
      decision_case.json
    logs/
      session_*.json
    templates/
      index.html        # 自己レビュー画面
    static/
      css/style.css
      js/app.js

## 11
- どのファイルに対応するコードなのかを明示すること（例：backend/app/main.py）

- 実行可能な完全なコード をファイル単位で出力すること

- ここに書いていない仕様を勝手に追加しないこと
（必要な場合は「仮仕様として〜と置く」というコメントをコード内に書く）

- 必要に応じて、最後に簡単な実行方法（例：uvicorn app.main:app --reload）をコメントで示すこと